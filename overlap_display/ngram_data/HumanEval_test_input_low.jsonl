{"instance": {"input": "\ndef check_dict_case(dict):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n", "references": ["    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n"], "id": "id95"}, "stats_key": {"light_scenario_key": {"scenario_spec": {"class_name": "helm.benchmark.scenarios.code_scenario.CodeScenario", "args": {"dataset": "humaneval"}}, "split": "test"}, "overlap_protocol_spec": {"n": 13}}, "instance_id": "id95", "annotated_input_overlap": {"part": "input", "annotated_entry_overlap": [["", 0], ["def", 0], ["check", 0], ["dict", 0], ["case", 0], ["dict", 0], ["given", 0], ["a", 0], ["dictionary", 0], ["return", 0], ["true", 1], ["if", 2], ["all", 2], ["keys", 2], ["are", 2], ["strings", 2], ["in", 2], ["lower", 0], ["case", 0], ["or", 0], ["all", 0], ["keys", 0], ["are", 0], ["strings", 0], ["in", 0], ["upper", 0], ["case", 0], ["else", 0], ["return", 0], ["false", 0], ["the", 0], ["function", 0], ["should", 0], ["return", 0], ["false", 0], ["is", 0], ["the", 0], ["given", 0], ["dictionary", 0], ["is", 0], ["empty", 0], ["examples", 0], ["check", 0], ["dict", 0], ["case", 0], ["a", 0], ["apple", 0], ["b", 0], ["banana", 0], ["should", 0], ["return", 0], ["true", 0], ["check", 0], ["dict", 0], ["case", 0], ["a", 0], ["apple", 0], ["a", 0], ["banana", 0], ["b", 0], ["banana", 0], ["should", 0], ["return", 0], ["false", 0], ["check", 0], ["dict", 0], ["case", 0], ["a", 0], ["apple", 0], ["8", 0], ["banana", 0], ["a", 0], ["apple", 0], ["should", 0], ["return", 0], ["false", 0], ["check", 0], ["dict", 0], ["case", 0], ["name", 0], ["john", 0], ["age", 0], ["36", 0], ["city", 0], ["houston", 0], ["should", 0], ["return", 0], ["false", 0], ["check", 0], ["dict", 0], ["case", 0], ["state", 0], ["nc", 0], ["zip", 0], ["12345", 0], ["should", 0], ["return", 0], ["true", 0], ["", 0]], "metrics": [{"metric_score": 1, "metric_protocol_spec": {"partial_overlap_spec": 0, "frequency_spec": {"filter_value": 0, "weighting": false}}}, {"metric_score": 0.08045977011494253, "metric_protocol_spec": {"partial_overlap_spec": 1, "frequency_spec": {"filter_value": 0, "weighting": false}}}, {"metric_score": 0.04597701149425287, "metric_protocol_spec": {"partial_overlap_spec": 1, "frequency_spec": {"filter_value": 0, "weighting": true}}}, {"metric_score": 0.1919191919191919, "metric_protocol_spec": {"partial_overlap_spec": 2, "frequency_spec": {"filter_value": 0, "weighting": false}}}, {"metric_score": 0.1919191919191919, "metric_protocol_spec": {"partial_overlap_spec": 2, "frequency_spec": {"filter_value": 0, "weighting": true}}}, {"metric_score": 1, "metric_protocol_spec": {"partial_overlap_spec": 0, "frequency_spec": {"filter_value": 10, "weighting": false}}}, {"metric_score": 0.08045977011494253, "metric_protocol_spec": {"partial_overlap_spec": 1, "frequency_spec": {"filter_value": 10, "weighting": false}}}, {"metric_score": 0.04597701149425287, "metric_protocol_spec": {"partial_overlap_spec": 1, "frequency_spec": {"filter_value": 10, "weighting": true}}}, {"metric_score": 0.1919191919191919, "metric_protocol_spec": {"partial_overlap_spec": 2, "frequency_spec": {"filter_value": 10, "weighting": false}}}, {"metric_score": 0.1919191919191919, "metric_protocol_spec": {"partial_overlap_spec": 2, "frequency_spec": {"filter_value": 10, "weighting": true}}}]}, "annotated_ref_overlap": {"part": "references", "annotated_entry_overlap": [["", 0], ["if", 0], ["len", 0], ["dict", 0], ["keys", 0], ["0", 0], ["return", 0], ["false", 0], ["else", 0], ["state", 0], ["start", 0], ["for", 0], ["key", 0], ["in", 0], ["dict", 0], ["keys", 0], ["if", 0], ["isinstance", 0], ["key", 0], ["str", 0], ["false", 0], ["state", 0], ["mixed", 0], ["break", 0], ["if", 0], ["state", 0], ["start", 0], ["if", 0], ["key", 0], ["isupper", 0], ["state", 0], ["upper", 0], ["elif", 0], ["key", 0], ["islower", 0], ["state", 0], ["lower", 0], ["else", 0], ["break", 0], ["elif", 0], ["state", 0], ["upper", 0], ["and", 0], ["not", 0], ["key", 0], ["isupper", 0], ["or", 0], ["state", 0], ["lower", 0], ["and", 0], ["not", 0], ["key", 0], ["islower", 0], ["state", 0], ["mixed", 0], ["break", 0], ["else", 0], ["break", 0], ["return", 0], ["state", 0], ["upper", 0], ["or", 0], ["state", 0], ["lower", 0], ["", 0]], "metrics": []}}
{"instance": {"input": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n", "references": ["    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n"], "id": "id21"}, "stats_key": {"light_scenario_key": {"scenario_spec": {"class_name": "helm.benchmark.scenarios.code_scenario.CodeScenario", "args": {"dataset": "humaneval"}}, "split": "test"}, "overlap_protocol_spec": {"n": 13}}, "instance_id": "id21", "annotated_input_overlap": {"part": "input", "annotated_entry_overlap": [["from", 0], ["typing", 0], ["import", 0], ["list", 0], ["def", 0], ["rescale", 0], ["to", 0], ["unit", 0], ["numbers", 0], ["list", 0], ["float", 0], ["list", 0], ["float", 0], ["given", 0], ["list", 0], ["of", 0], ["numbers", 0], ["of", 0], ["at", 0], ["least", 0], ["two", 0], ["elements", 0], ["apply", 0], ["a", 0], ["linear", 0], ["transform", 0], ["to", 0], ["that", 0], ["list", 0], ["such", 0], ["that", 0], ["the", 0], ["smallest", 0], ["number", 0], ["will", 0], ["become", 0], ["0", 0], ["and", 0], ["the", 0], ["largest", 0], ["will", 0], ["become", 0], ["1", 0], ["rescale", 0], ["to", 0], ["unit", 0], ["1", 7], ["0", 0], ["2", 0], ["0", 0], ["3", 0], ["0", 0], ["4", 0], ["0", 0], ["5", 0], ["0", 0], ["0", 0], ["0", 0], ["0", 0], ["25", 0], ["0", 0], ["5", 0], ["0", 0], ["75", 0], ["1", 0], ["0", 0], ["", 0]], "metrics": [{"metric_score": 1, "metric_protocol_spec": {"partial_overlap_spec": 0, "frequency_spec": {"filter_value": 0, "weighting": false}}}, {"metric_score": 0.01818181818181818, "metric_protocol_spec": {"partial_overlap_spec": 1, "frequency_spec": {"filter_value": 0, "weighting": false}}}, {"metric_score": 0.0025974025974025974, "metric_protocol_spec": {"partial_overlap_spec": 1, "frequency_spec": {"filter_value": 0, "weighting": true}}}, {"metric_score": 0.19402985074626866, "metric_protocol_spec": {"partial_overlap_spec": 2, "frequency_spec": {"filter_value": 0, "weighting": false}}}, {"metric_score": 0.0277185501066098, "metric_protocol_spec": {"partial_overlap_spec": 2, "frequency_spec": {"filter_value": 0, "weighting": true}}}, {"metric_score": 1, "metric_protocol_spec": {"partial_overlap_spec": 0, "frequency_spec": {"filter_value": 10, "weighting": false}}}, {"metric_score": 0.01818181818181818, "metric_protocol_spec": {"partial_overlap_spec": 1, "frequency_spec": {"filter_value": 10, "weighting": false}}}, {"metric_score": 0.0025974025974025974, "metric_protocol_spec": {"partial_overlap_spec": 1, "frequency_spec": {"filter_value": 10, "weighting": true}}}, {"metric_score": 0.19402985074626866, "metric_protocol_spec": {"partial_overlap_spec": 2, "frequency_spec": {"filter_value": 10, "weighting": false}}}, {"metric_score": 0.0277185501066098, "metric_protocol_spec": {"partial_overlap_spec": 2, "frequency_spec": {"filter_value": 10, "weighting": true}}}]}, "annotated_ref_overlap": {"part": "references", "annotated_entry_overlap": [["", 0], ["min", 0], ["number", 0], ["min", 0], ["numbers", 0], ["max", 0], ["number", 0], ["max", 0], ["numbers", 0], ["return", 0], ["x", 0], ["min", 0], ["number", 0], ["max", 0], ["number", 0], ["min", 0], ["number", 0], ["for", 0], ["x", 0], ["in", 0], ["numbers", 0], ["", 0]], "metrics": []}}
{"instance": {"input": "\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    You are given a rectangular grid of wells. Each row represents a single well,\n    and each 1 in a row represents a single unit of water.\n    Each well has a corresponding bucket that can be used to extract water from it, \n    and all buckets have the same capacity.\n    Your task is to use the buckets to empty the wells.\n    Output the number of times you need to lower the buckets.\n\n    Example 1:\n        Input: \n            grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output: 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n        * all wells have the same length\n        * 1 <= grid.length <= 10^2\n        * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n        * 1 <= capacity <= 10\n    \"\"\"\n", "references": ["    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n"], "id": "id115"}, "stats_key": {"light_scenario_key": {"scenario_spec": {"class_name": "helm.benchmark.scenarios.code_scenario.CodeScenario", "args": {"dataset": "humaneval"}}, "split": "test"}, "overlap_protocol_spec": {"n": 13}}, "instance_id": "id115", "annotated_input_overlap": {"part": "input", "annotated_entry_overlap": [["", 0], ["def", 0], ["max", 0], ["fill", 0], ["grid", 0], ["capacity", 0], ["import", 0], ["math", 0], ["you", 0], ["are", 0], ["given", 0], ["a", 0], ["rectangular", 0], ["grid", 0], ["of", 0], ["wells", 0], ["each", 0], ["row", 0], ["represents", 0], ["a", 0], ["single", 0], ["well", 0], ["and", 0], ["each", 0], ["1", 0], ["in", 0], ["a", 0], ["row", 0], ["represents", 0], ["a", 0], ["single", 0], ["unit", 0], ["of", 0], ["water", 0], ["each", 0], ["well", 0], ["has", 0], ["a", 0], ["corresponding", 0], ["bucket", 0], ["that", 0], ["can", 0], ["be", 0], ["used", 0], ["to", 0], ["extract", 0], ["water", 0], ["from", 0], ["it", 0], ["and", 0], ["all", 0], ["buckets", 0], ["have", 0], ["the", 0], ["same", 0], ["capacity", 0], ["your", 0], ["task", 0], ["is", 0], ["to", 0], ["use", 0], ["the", 0], ["buckets", 0], ["to", 0], ["empty", 0], ["the", 0], ["wells", 0], ["output", 0], ["the", 0], ["number", 0], ["of", 0], ["times", 0], ["you", 0], ["need", 0], ["to", 0], ["lower", 0], ["the", 0], ["buckets", 0], ["example", 0], ["1", 0], ["input", 0], ["grid", 0], ["0", 0], ["0", 0], ["1", 0], ["0", 0], ["0", 0], ["1", 0], ["0", 0], ["0", 0], ["1", 0], ["1", 0], ["1", 0], ["1", 0], ["bucket", 0], ["capacity", 0], ["1", 0], ["output", 0], ["6", 0], ["example", 0], ["2", 0], ["input", 0], ["grid", 0], ["0", 390], ["0", 173], ["1", 135], ["1", 70], ["0", 0], ["0", 0], ["0", 0], ["0", 0], ["1", 0], ["1", 0], ["1", 0], ["1", 0], ["0", 0], ["1", 0], ["1", 0], ["1", 0], ["bucket", 0], ["capacity", 0], ["2", 0], ["output", 0], ["5", 0], ["example", 0], ["3", 0], ["input", 0], ["grid", 0], ["0", 0], ["0", 0], ["0", 0], ["0", 0], ["0", 0], ["0", 0], ["bucket", 0], ["capacity", 0], ["5", 0], ["output", 0], ["0", 0], ["constraints", 0], ["all", 0], ["wells", 0], ["have", 0], ["the", 0], ["same", 0], ["length", 0], ["1", 0], ["grid", 0], ["length", 0], ["10", 0], ["2", 0], ["1", 0], ["grid", 0], ["1", 0], ["length", 0], ["10", 0], ["2", 0], ["grid", 0], ["i", 0], ["j", 0], ["0", 0], ["1", 0], ["1", 0], ["capacity", 0], ["10", 0], ["", 0]], "metrics": [{"metric_score": 1, "metric_protocol_spec": {"partial_overlap_spec": 0, "frequency_spec": {"filter_value": 0, "weighting": false}}}, {"metric_score": 0.025974025974025976, "metric_protocol_spec": {"partial_overlap_spec": 1, "frequency_spec": {"filter_value": 0, "weighting": false}}}, {"metric_score": 0.00019504916284437338, "metric_protocol_spec": {"partial_overlap_spec": 1, "frequency_spec": {"filter_value": 0, "weighting": true}}}, {"metric_score": 0.0963855421686747, "metric_protocol_spec": {"partial_overlap_spec": 2, "frequency_spec": {"filter_value": 0, "weighting": false}}}, {"metric_score": 0.0012136514608831624, "metric_protocol_spec": {"partial_overlap_spec": 2, "frequency_spec": {"filter_value": 0, "weighting": true}}}, {"metric_score": 0, "metric_protocol_spec": {"partial_overlap_spec": 0, "frequency_spec": {"filter_value": 10, "weighting": false}}}, {"metric_score": 0.0, "metric_protocol_spec": {"partial_overlap_spec": 1, "frequency_spec": {"filter_value": 10, "weighting": false}}}, {"metric_score": 0.0, "metric_protocol_spec": {"partial_overlap_spec": 1, "frequency_spec": {"filter_value": 10, "weighting": true}}}, {"metric_score": 0.0, "metric_protocol_spec": {"partial_overlap_spec": 2, "frequency_spec": {"filter_value": 10, "weighting": false}}}, {"metric_score": 0.0, "metric_protocol_spec": {"partial_overlap_spec": 2, "frequency_spec": {"filter_value": 10, "weighting": true}}}]}, "annotated_ref_overlap": {"part": "references", "annotated_entry_overlap": [["", 0], ["return", 0], ["sum", 0], ["math", 0], ["ceil", 0], ["sum", 0], ["arr", 0], ["capacity", 0], ["for", 0], ["arr", 0], ["in", 0], ["grid", 0], ["", 0]], "metrics": []}}
